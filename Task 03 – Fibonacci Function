int fib(int n)

{

       if (n <= 0) // base case

            return 0;

      else if (n == 1) // base case

             return 1;

       else

             return fib(n – 1) + fib(n – 2);

}

1. what is the time complexity of this algorithm and why?
It's O(2ⁿ) because each call spawns two more calls, forming a binary tree of recursive calls. This leads to exponential growth in the number of calls.
